/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * ModelTreeDialog.java
 *
 * Created on 2009-7-11, 14:43:57
 */
package org.jhrcore.ui;

import java.awt.BorderLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;
import javax.swing.JScrollPane;
import javax.swing.JTree;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreePath;
import org.jhrcore.util.SysUtil;
import org.jhrcore.ui.renderer.HRRendererView;
import org.jhrcore.util.ComponentUtil;

/**
 *
 * @author mxliteboss
 * 此对话框主要用于以树状显示各种数据，并根据用户选择返回需要的对象，支持多选
 */
public class ModelTreeDialog extends javax.swing.JDialog {

    private boolean click_ok = false;
    private boolean select_many = false;
    private List select_objs = new ArrayList();
    private JTree model_tree;
    private List<DefaultMutableTreeNode> selected_nodes = new ArrayList<DefaultMutableTreeNode>();
    private DefaultMutableTreeNode rootNode;
    private DefaultMutableTreeNode select_node;
    private int sum = 0;
    private int index = 0;
    private String cur_str = "";

    public boolean isClick_ok() {
        return click_ok;
    }

    public List getSelect_objs() {
        return select_objs;
    }

    public ModelTreeDialog(java.awt.Frame parent, String title, boolean select_many, DefaultMutableTreeNode rootNode, DefaultMutableTreeNode select_node) {//, TreeCellRenderer renderer) {
        super(parent);
        this.setTitle(title);
        this.select_many = select_many;
        this.rootNode = rootNode;
        this.select_node = select_node;
        initComponents();
        initOthers();
        setupEvents();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        pnlMain = new javax.swing.JPanel();
        jSeparator1 = new javax.swing.JSeparator();
        btnOk = new javax.swing.JButton();
        btnCancel = new javax.swing.JButton();
        pnlSearch = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jtfSearch = new javax.swing.JTextField();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setModal(true);

        pnlMain.setLayout(new java.awt.BorderLayout());

        btnOk.setText("确定");

        btnCancel.setText("取消");

        jLabel1.setText("查找：");

        javax.swing.GroupLayout pnlSearchLayout = new javax.swing.GroupLayout(pnlSearch);
        pnlSearch.setLayout(pnlSearchLayout);
        pnlSearchLayout.setHorizontalGroup(
            pnlSearchLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnlSearchLayout.createSequentialGroup()
                .addGap(59, 59, 59)
                .addComponent(jLabel1)
                .addGap(18, 18, 18)
                .addComponent(jtfSearch, javax.swing.GroupLayout.PREFERRED_SIZE, 124, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(163, Short.MAX_VALUE))
        );
        pnlSearchLayout.setVerticalGroup(
            pnlSearchLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnlSearchLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(pnlSearchLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(jtfSearch, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(233, Short.MAX_VALUE)
                .addComponent(btnOk)
                .addGap(18, 18, 18)
                .addComponent(btnCancel)
                .addGap(35, 35, 35))
            .addComponent(jSeparator1, javax.swing.GroupLayout.DEFAULT_SIZE, 400, Short.MAX_VALUE)
            .addComponent(pnlSearch, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addComponent(pnlMain, javax.swing.GroupLayout.DEFAULT_SIZE, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addComponent(pnlSearch, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(pnlMain, javax.swing.GroupLayout.DEFAULT_SIZE, 362, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(btnCancel)
                    .addComponent(btnOk))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnCancel;
    private javax.swing.JButton btnOk;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JTextField jtfSearch;
    private javax.swing.JPanel pnlMain;
    private javax.swing.JPanel pnlSearch;
    // End of variables declaration//GEN-END:variables

    private void initOthers() {
        model_tree = new JTree(rootNode);
        HRRendererView.getParaFieldTypeMap(model_tree).initTree(model_tree, select_many ? TreeSelectMod.nodeCheckMod : TreeSelectMod.nodeSelectMod);
        model_tree.setRootVisible(false);
        model_tree.setShowsRootHandles(true);
        pnlMain.add(new JScrollPane(model_tree), BorderLayout.CENTER);
        ComponentUtil.initTreeSelection(model_tree, select_node);
    }

    private void setupEvents() {
        if (!select_many) {
            model_tree.addMouseListener(new MouseAdapter() {

                @Override
                public void mouseClicked(MouseEvent e) {
                    if (e.getClickCount() != 2) {
                        return;
                    }
                    if (!clickNode()) {
                        return;
                    }
                    click_ok = true;
                    dispose();
                }
            });
        }

        btnOk.addActionListener(new ActionListener() {

            @Override
            public void actionPerformed(ActionEvent e) {
                select_objs.clear();
                if (select_many) {
                    Enumeration enumt = rootNode.breadthFirstEnumeration();
                    while (enumt.hasMoreElements()) {
                        CheckTreeNode node = (CheckTreeNode) enumt.nextElement();
                        if (node == rootNode) {
                            continue;
                        }
                        if (node.isSelected()) {
                            Object obj = node.getUserObject();
                            select_objs.add(obj);
                        }
                    }
                } else {
                    if (!clickNode()) {
                        return;
                    }
                }

                click_ok = true;
                dispose();
            }
        });
        btnCancel.addActionListener(new ActionListener() {

            @Override
            public void actionPerformed(ActionEvent e) {
                dispose();
            }
        });
        jtfSearch.addKeyListener(new KeyListener() {

            @Override
            public void keyTyped(KeyEvent e) {
            }

            @Override
            public void keyPressed(KeyEvent e) {
                if (e.getKeyCode() == 10) {
                    Locate(1, jtfSearch.getText());
                }
            }

            @Override
            public void keyReleased(KeyEvent e) {
            }
        });
    }

    private boolean clickNode() {
        TreePath path = model_tree.getSelectionPath();
        if (path == null) {
            return false;
        }
        DefaultMutableTreeNode node = (DefaultMutableTreeNode) path.getLastPathComponent();
        if (node == null) {
            return false;
        }
        if (node.getChildCount() > 0) {
            return false;
        }
        select_objs.add(node.getUserObject());
        return true;
    }

    public void Locate(int step, String text) {
        if (text == null || text.replace(" ", "").equals("")) {
            return;
        }
        String tmp_str = text.replace(" ", "");
        index = index + step;
        if (!tmp_str.equals(cur_str)) {
            index = 0;
            cur_str = tmp_str;
            selected_nodes.clear();
            selected_nodes.addAll(SysUtil.locateEmp(model_tree, cur_str));
            sum = selected_nodes.size();
        }
        if (sum == 0) {
            return;
        }
        if (index == -1) {
            index = sum - 1;
        } else if (index >= sum) {
            index = 0;
        }
        locateNode(index);
    }

    private void locateNode(int i) {
        select_node = (DefaultMutableTreeNode) selected_nodes.get(i);
        if (select_node == null) {
            return;
        }
        ComponentUtil.initTreeSelection(model_tree, select_node);
    }
}
